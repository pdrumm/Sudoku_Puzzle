Patrick Drumm
Lab 6, cse20212


Note: Please run my program on the extra Coder Challenge sudoku puzzles!


User's Perspective:
	From the user's perspective, this program can be a useful tool for if you cannot seem to solve a certain sudoku, want to check your answer, or maybe if you want to cheat and then "show off" to your friends how quickly you can solve the puzzle! The purpose of this program is quite straightforward. Given a .txt file input that contains the outline of a 9x9 sudoku puzzle, this program will try to solve it.
	The program will first ask the user for the filename. If the file does not exist, then the program tells the user that an error has occured and then exists. If the file does exist, then the program will next display the unsolved sudoku in a nicer form than what is seen in the .txt file. The program then attempts to solve the sudoku. If the sudoku was not solved, the program tells the user that it was not solved, and then prints out the filled in sudoku, showing how far the program got. If the program can solve the puzzle, then it tells the user that the sudoku has been solved, and then prints out the solution.


Programmer's Perspective:
	From the programmer's perspective, this program is a good example of multi-dimensional vectors. Consequentally, it is also quite a maze of for-loops. 
	This program begins by reading in a 9x9 vector from a text file and saving it to a 2D vector. Next, this program takes its first step towards solving the puzzle by creating a 3D vector of possible values for the sudoku. For each cell in the puzzle, there is a corresponding vector of possible values (1-9) stored. This is created by checking if each number 1-9 is valid for each cell in the board. If any value is valid for a given cell, then the 3D vetor pushes that value back in the cell's corresponding location. 
	After this 3D vector of possible values is created, no values will ever be added to the vector. Values can only be removed. 
	This program then implements three algorithms, and uses a fourth function that keeps the 3D possible value vector up to date.
	The first and most straightforward algorithm used is the scanning (or single possibility) algorithm. This algorithm goes through the 3D possible value vector and check to see how many possible values exist for each cell on the puzzle. If only one possible value exists, then this algorithm sets that cell of the solution board equal to that single possible value.
	The second algorithm is the singleton algorithm. The singleton algorithm checks every row, column, and minigrid of the board. If for any given row, column, or minigrid, there exists only one cell that has a certain possible value, then that cell must be that value. This is because every row, column, and minigrid must have exactly one occurence of every value. When the singleton algorithm finds a case of this, then it sets the corresponding cell in the solution board equal to that value(that was only found once).
	It is important to note that these first two algorithms use the 3D vector, but affect only the 2D solution matrix. That is, neither of these algorithms are written to change the 3D possible values vector. Thus, this program uses a function called updatePosVals() that does that very thing. The main driver is written such that after the scanning or singleton algorithm is used, updatePosVals() is then called. This function then goes through the 3D possible value vector, and erases any values that are no longer possible thanks to the updated solution board.
	Finally, the third algorithm used I have ever so creatively called the Patrick algorithm. This algorithm is used as a "last chance" to solving the puzzle, when neither the scanning or singleton algorithm are having any further effect. Contrary to the first two algorithms, the Patrick algorithm does not solve anything on the solution board, rather it attempts to erase some possible values from the 3D vector. This algorithm checks every row and column. For a given row or column, if n equal possible value vectors of size n are found, then no other cells in that row or column can possible be any of those values in the matching possible value vectors. Thus, any value found in the equal possible value vectors is consequentally erased from the other cells' possible value vectors.
	Together, these algorithms and functions attempt to slim down the 3D possible value vector until it has only one possible value for each of the 81 corresponding cells on the puzzle board.
	The program will continue to run until updatePosVals() no longer is making any updates to the board after applying the algorithms, meaning that the puzzle can be solved no further(either because it is stuck, or because the puzzle is solved completely). The program then tells the user if the puzzle has or has not been solved, and then outputs the filled in (or partially filled in) solution to the sudoku.


Evaluation for Correctness:
	To evaluate this program for correctness, I created the algorithms one at a time, and one piece at a time to ensure that each piece was working before I started on the next one. In addition to stepping through, I also printed out the 3D possible value vector. This allowed me to visually see if the possible values for each cell were correct based on the solution matrix.
	By doing this, I could catch the logic flaws in my code immendiately, and could locate them fairly easily because I had not added too much code since verifying for correctness last. For example, in the singleton algorithm, my code is written such that checking the rows is independent from checking the columns and minigrids. Thus, I wrote the singleton algorithm for just the rows first. Since I had already written the scanning algorithm and seen the 3D possible value vector when the scanning algorithm could solve no further, I knew exactly where the singleton should have an effect and I knew what the effect would be. Once I verified that the singleton worked correctly for rows, I went on to implement the singleton for columns.
	In addition to stepping through the algorithm, another way that I verified that my program worked correctly was by evaluating the final output. When the program filled in a value for every cell and outputted a solution, I checked through the solution to make sure that there was exactly one value 1-9 in each row, column, and minigrid. 
	I also test my executable to make sure that it acted the way I wanted to when a solution could not be found. And I made sure that my code acted the way I wanted to when an invalid filename was inputted by the user.


What did and did not work well and "how" it was implemented:
	Something that did not work well was using a vector of actual possible puzzle values, instead of representing those possible values with a "bit vector" where each value was either possible(1) or not possible(0). While pushing back the possible values did have certain advantages, I believe that it did have a disadvantage in regards to efficiency.
	For example, whenever I needed to change a value that was previously possible, to no longer being possible. At the beginning of the program, my code pushes back every possible value for each cell. Then as the program finds solutions in the puzzle, possible values are erased. This came to be more difficult than it had to be, due to my pushing back the actual possible values. If a value was not a possible value, I had to loop through my possible value vector and search until I found the location of that value, and then erase it. If I had used the bitwise representation of possible values, rather than looping through and searching for the value I found to be invalid, I could just set that bit to zero because I would have already known the exact location of that bit.
	Something that did work well for me is my additional algorithm. I wanted to try to implement at least one additional algorithm, so I looked at a few sudokus on my own and tried to see how I solved puzzles (in addition to the scanning and singleton algorithms). What I found, is that whenever there were two cells in the same row, that had the exact two same possible valus, I would eliminate those two possible values from all the other cells in the row. This also works for columns and minigrids(however, I did not chose to implement this algorithm for the minigrids). I also found that if I generalized this to n equal possible value vectors, each with the same n values that this algorithm still held true. 
	This worked well because by eliminating some of those possible values using this algorithm, this opens the door for the scanning algorithm to potentially find more solutions if this algorithm eliminated all but one possible values from a cell. I could confirm that this algorithm had an effect because there were harder level sudoku puzzles that my program could not previously solve, but now my program could solve after implementing this.
